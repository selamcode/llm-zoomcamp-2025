# Docker 
##### Before going to docker it's important to understand Virtual Machine.

## ğŸŒ **What is a Virtual Machine (VM)?**

### ğŸš© **`Why Do We Even Need a Virtual Machine`?**

Imagine you only have **one computer**, but you want to:

- Try **Linux** while using **Windows**.
- **Experiment** with software or settings that might break your system.
- Learn about servers, networks, or hacking without messing up your real system.

Normally, you'd need **multiple computers**. Thatâ€™s expensive, slow, and unrealistic.

ğŸ’¡ **Virtual Machines** solve this. They let you run **many computers inside one computer** â€” like magic.

### ğŸ§  **`What is a Virtual Machine, Really`?**

A `Virtual Machine` (VM) is a computer inside your computer.

Itâ€™s **not fake** â€” it behaves like a real one. It has:

- Its **own operating system** (like Ubuntu Linux),
- Its own **`storage`**, **`RAM`**, and even a **`fake CPU`**,
- And it runs in a **window** on your main computer.

You're basically **pretending to have a whole new computer** â€” without buying one.

ğŸ–¥ï¸ Example:

- You're on a Windows laptop.
- You open a program like **VirtualBox**.
- Inside it, you open **Ubuntu Linux** â€” like opening Chrome or Word.

Now youâ€™re using two computers at once. ğŸ‰

#### ğŸ”§ **`How Do Virtual Machines Work?`**

To run a virtual machine, you need:

1. **`A physical computer`** (the real one you own) â†’ this is called the **host**.
2. **`Virtualization software (Hypervisor)`**  â†’ this is a special app that helps you create and run VMs.
    - Examples: **VirtualBox**, **VMware**, **Parallels**.
3. **`An ISO file`** of the `OS` you want to install â†’ like Ubuntuâ€™s installer.

#
![virtual machines](images/vm1.png)

### Here's what happens:

- You install **VirtualBox** on your Windows.
- You tell VirtualBox: â€œHey, create a fake computer with 4GB RAM and 30GB storage.â€
- You install Ubuntu inside that fake computer.
- Boom! Now Ubuntu is running in a window â€” inside your real Windows computer.

The VM has **no idea** itâ€™s not real. It thinks itâ€™s a full PC.

## ğŸ›¡ï¸ **Why Are VMs So Cool?**

Letâ€™s break it down:

| Benefit | Why It Matters |
| --- | --- |
| ğŸ§ª Try Anything Safely | Break stuff, learn, test â€” your real computer is safe. |
| ğŸ§  Learn New OSes | Use Linux, Windows, or even old systems without dual-boot. |
| ğŸ“‚ Keep Things Separate | Set up labs, test viruses, or run a web server â€” without mixing with your real setup. |
| ğŸ’¾ Snapshots | Save your VMâ€™s state. If you mess up, go back in time. Like checkpoints in a video game. |
| ğŸ“¦ Portable | Move your VM to another computer like a file. It works the same. |
| ğŸ’» Use Old Software | Got apps that only run on Windows XP? Use a VM. |

## âš™ï¸ **`What is a Hypervisor? (Simple Explanation)`**

A **`hypervisor`** is the sofwtare **that makes virtual machines possible**.

There are 2 types:

1. **`Type 1 (Bare-metal)`**: Installed directly on the hardware. Used in big servers (like AWS or Microsoft Azure).
2. **`Type 2 (Hosted)`**: Runs inside your normal OS (like Windows). You use this. Example: VirtualBox.

So, VirtualBox is a **Type 2 hypervisor**. It lets you make and run fake computers (VMs) **inside your real one**.

### ğŸ”§ **`Why Virtual Machines (VMs) Arenâ€™t Perfect â€“ â€œVMwartsâ€ Explained`**

Even though **virtual machines** are a big improvement over running everything directly on one system, they come with their own set of **downsides** â€” or as this section calls them, *â€œVMwarts.â€*

Letâ€™s walk through these problems one by one:

### ğŸ§± 1. **`Every Virtual Machine Needs Its Own Full Operating System`**

Imagine you want to run 3 different applications in isolation using virtual machines. Youâ€™d have to do this:

- Create **3 separate VMs**
- Install **an entire OS** (like Ubuntu or Windows) **on each VM**
- Then install your apps inside each one

That means **each VM is like a full computer** inside your computer.

### âŒ `Why This Is a Problem`

### **`Wasted Resources`**

- Every operating system needs **RAM**, **CPU**, **storage**, and **networking** power â€” even before it runs any app.
- Instead of spending your machine's power on your *apps*, itâ€™s being used just to keep **multiple full OSs** alive.

### **`More Work to Maintain`**

- Each VM has its own OS.
- So if your OS has bugs or security issues, you need to **patch or update** it.
- Now imagine doing that for **10 or 100 VMs** ğŸ˜¬.

### **`Monitoring Headache`**

- Each VM needs **monitoring**: you have to keep track of its resource usage, errors, logs, etc.
- Again, the more VMs you have, the more complex this becomes.

### **`Slow Boot Time`**

- Because each VM boots an entire operating system, **starting one can take a long time** (compared to apps or containers).

### **`Not Very Portable`**

- A VM image (like `.vmdk` or `.ova`) can be **huge** in size.
- If you move a VM to another machine, it may **not work out of the box** unless that machine supports the same virtual hardware.

---

### ğŸ“Œ `Summary of VM Drawbacks`:

| Drawback | What It Means |
| --- | --- |
| OS Overhead | Resources used by the OS instead of your app |
| Maintenance | Each OS needs updates and patching |
| Monitoring Complexity | More moving parts to keep track of |
| Slower Start-up | Takes time to boot an OS |
| Poor Portability | Not easy to move or share VMs |

---

### ğŸš€ Coming Next: Containers

These problems are the **reason containers were invented**.

**`VMs and containers are very different under the hood`**:

- **VMs** virtualize the entire hardware â€” each VM runs its own full OS on virtual hardware, which makes them heavier and slower but great for running different OSes or fully isolated systems.
- **Containers** virtualize at the OS level â€” they share the host OS kernel and just isolate the application and its dependencies, making them lightweight, fast, and efficient, but all containers share the same OS kernel.

### `What is a Container?`

- A **container** is like a small, portable box that holds an application and everything it needs to run â€” like code, libraries, and settings.
- Containers share the **host operating systemâ€™s kernel** but keep apps **isolated** from each other.
- Because containers share the OS kernel, they are **lightweight and fast** compared to virtual machines.

---

### `Why Do We Need Containers?`

- Traditional virtual machines run a full OS for each app, which is heavy and uses a lot of resources.
- Containers solve this by **sharing the host OS kernel** but still keeping each app isolated and safe.
- Containers are **easy to move** between different environments (your laptop, servers, cloud) because they include everything the app needs (except the OS kernel).

---

### `How Do Containers Work Across Different Operating Systems?`

- Containers run **directly on the host OS kernel** if it supports the containerâ€™s OS (usually Linux).
- On **Linux hosts**, containers run natively using the Linux kernel.
- On **Windows or Mac**, containers that require Linux run **inside a lightweight Linux virtual machine**.
    
    This VM provides the Linux kernel needed, so the container runs smoothly even though the host OS is different.
    
- This means **containers rely on virtual machines only when the host OS lacks the required kernel**.

## `WebAssembly (Wasm)`

is a modern binary instruction set that builds applications that are smaller, faster, more secure, and more portable than containers. You write your app in your favorite language and compile it as a Wasm binary, and itâ€™ll run anywhere you have a Wasm runtime.

However, Wasm apps have many limitations, and weâ€™re still developing many of the standards. As a result, containers remain the dominant model for cloud-native applications.

### **`What about Kubernetes`**

Kubernetes is the industry standard platform for deploying and managing containerized apps.

**`Terminology:`** `A containerized app is an application running as a container.`





# **`Docker`** <img src="images/docker5.svg" alt="Movie Poster" width="70"/>

### ğŸ³ `What is Docker?`

`Docker` is a **`tool that helps you create and run containers`** easily. Think of containers as small, packaged-up versions of your app that can run anywhere â€” kind of like an app in a box that works the same on any computer.

### ğŸ§© `Docker Has Two Main Parts:`

### 1. ğŸ§‘â€ğŸ’» `Docker CLI (Command-Line Interface) â€” The Client`

- This is what **you interact with**.
- You type commands like `docker run`, `docker build`, etc.
- Itâ€™s like your **remote control** for Docker.

### 2. âš™ï¸ **`Docker Engine â€” The Server`**

- This is the **actual machine behind the scenes** doing the work.
- Itâ€™s like the **robot that listens to your remote control (CLI)** and makes things happen.

![](images/docker1.png)

### ğŸ§™â€â™‚ï¸ `What is a **Daemon**?`

A **`daemon`** (pronounced *DEE-muhn*) is just a **background program** that runs quietly behind the scenes and **waits for tasks to do**.

### ğŸ”§ In simple terms:

- It **starts automatically** when your system boots up.
- It **runs without needing your attention**.
- It **waits for requests** and does jobs when asked.

### ğŸ³ `In Docker`

- It runs in the background.
- It listens for commands from the **Docker CLI**.
- It manages:
    - Running containers
    - Pulling images
    - Building images
    - Networking between containers
    - Volumes (data storage)
    

![](images/docker2.png)

# The Big Idea of Docker in Summary:

- Docker containers need the **Linux kernel** to work.
- So when you use Docker on **Windows or macOS**, it runs a **small Linux virtual machine (VM)** in the background. This is why VM is useful for docker.
- Your containers run **inside this VM**, not directly on your main OS.
- On **Linux**, Docker runs directly without a VM, since it already has the right kernel.


#
![](images/docker3.png)
#


## **`The Big Picture`**

- `The Ops Perspective`
- `The Dev perspective`

â†’ `The Ops Perspective`: focuses on starting, stopping, deleting containers, and executing
commands inside them.

â†’ `The dev perspective`: focuses more on the application side of things and runs through
taking application source code, building it into a container image, and running it as a
container.

